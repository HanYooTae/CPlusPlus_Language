#include <iostream>

using namespace std;

/*
	가독성이 떨어짐
	무슨 타입이 들어오는지 알 수 없다. 대신 어떤 타입이든 들어올 수 있다.
	디버깅이 안된다.
*/
#define MAX(a,b) (((a) > (b)) ? (a) : (b))		//변수가 아닌 다른 것으로 인식할 수도 있으므로 스코프를 해줘야 함
												//모든 타입을 사용이 가능하다. 장점이자 단점

/*
	
*/
inline int Max(int a, int b)		//매크로처럼 복붙이 가능함. 같은 것은 아니다.	inline은 디버깅이 가능하다
{
	return (a > b) ? a : b;
}

/*
   inline
   - 매크로와 같이 컴파일된 함수 코드가 프로그램의 코드안에 직접 삽입된다.
   - 함수 호출에 의한 성능저하가 없어 일반적인 함수보다 속도면에서 유리하다.
   - 여러번 호출되거나 덩치가 큰 함수에 사용할 경우 프로그램의 크기가 커질 수 있다.
   - 빈번하게 호출이 있는 짧은 함수를 사용할 때 유리하다. 그렇지 않은 함수에
   사용한 경우에는 성능 향상이 미비하다.
   - 긴 함수를 인라인화 하려는 경우 컴파일러가 무시할 가능성이 있다.
   - 최신 컴파일러는 함수를 인라인화 하여 코드를 사용할 필요는 없음.
*/

/*
   inline과 macro의 차이
   - 매크로는 오류방지를 위해 모든 인자를 괄호로 묶어 가독성이 좋지 않다.
   인라인은 일반적인 함수와 형식이 비슷해 괄호로 묶을 필요가 없다.

   - 매크로는 인수타입(자료형)을 명시하지 않는다.
   인라인은 인수의 타입을 명시해야 한다. (단, 템플릿을 이용하면 명시하지 않아도 됨. -> 확실하지 않음)

   - 매크로는 단순 텍스트 치환이기에 복잡한 함수의 기능 구현이 어렵다.
   인라인은 일반적인 함수와 형식이 비슷해 함수의 모든 기능을 구현할 수 있다.

   - 매크로는 단순치환이라 디버깅x
   인라인은 디버깅o
*/

/*
	inline과 일반 함수의 차이점
	https://placeforjake.tistory.com/44

	- 인라인 함수는 프로그램의 실행 속도를 높이기 위해 추가된 기능
	- 인라인과 일반 함수의 가장 큰 차이점은 함수의 호출 방식
		ㄴ 일반 함수 : 프로그램 실행 중 함수를 실행해야하면 해당 함수의 주소로 점프시켰다가 함수의 처리가 종결되면 다시 원래의 자리로 돌아온다.
		ㄴ 인라인 함수 : 컴파일된 함수 코드가 프로그램의 코드 안에 직접 삽입됨. 함수가 호출되는 대신, 그에 대응하는 함수 코드로 대체됨.
						 함수의 호출없이 삽입된 함수 코드를 그 자리에서 처리하기 때문에 속도면에서 유리

	- 프로그래머가 inline선언을 해도 컴파일러가 거부할 수 있음.
	- 프로그래머가 inline선언을 하지 않아도 컴파일러가 inline화할 수 있음.
	- 함수의 덩치가 크거나 재귀호출일 경우, inline화가 거부될 수 있음.

	- 메모리 사용 측면에서는 인라인 함수가 일반 함수보다 불리.
		ㄴ 프로그램에서 인라인 함수를 열 번 호출한다면, 프로그램은 그 함수의 사본을 프로그램의 코드 안에 열 번이나 삽입해야 함.
*/

int main()
{
	cout << Max(1, 2) << endl;		//Max함수로 갔다가 다시 main으로 돌아옴 (오버헤드 : 성능저하)
	cout << MAX(1, 2) << endl;

	return 0;
}

